import blockchain;

vector Nfts <Bytes32>

// 一次给多个用户转账
vector Targets <Bytes32>;

// 一次原始转账交易
// 可支持同时转出多个所属的NFT，Nfts的数量与Targets的数量必须相同
table RawTransferTransaction {
  nft_ids: Nfts,  // 本交易指定的ledger cell的type_id,
  to:      Targets, // 同时给多人转账
}

// 一次原始NFT分发交易
// 支持一笔交易分发多个NFT，token_id根据顺序递增
table RawDistributeTransaction {
    class_id: Byte32,
    to:       Targets,
}

// 一次原始NFT发行交易
table RawIssueTransaction {
    total:       Uint32,
    configure:   byte,
    to:          Bytes32,
    name:        Bytes
    description: Bytes 
}

vector EXTDATAS <Bytes>

// 给某种类型的NFT增加额外数据
// 可以批量更新，但只支持同类型
table RawUpdateTransaction {
    type:      byte,
    hash_ids:  Nfts,     // 本交易指定的key,
    ext_datas: EXTDATAS, // 每个Key的新的ext_datas项
}

// 将某些Key value从SMT抽取出来成为Cell
// 可以批量抽取，但只支持同类型
// 检测到此类交易后，会去outputs里寻找是否有匹配的cell
table RawExtractTransaction {
    type:      byte,
    hash_ids:  Nfts,     // 本交易指定的key,
}

// 将某些Key value从Cell中插入SMT
// 可以批量插入，但只支持同类型
// 检测到此类交易后，会去inputs里寻找是否有匹配的cell
table RawInsertTransaction {
    type:      byte,
    hash_ids:  Nfts,     // 本交易指定的key,
}

table Transaction {
    type: byte,
    transaction: Bytes,
    signature: Bytes,
}

// 一系列交易
vector TransactionVec <Transaction>;

// SMT的更新项
struct SmtUpdateItem {
    key:       Byte32,       //本更新项的Key
    old_value: Bytes, //本更新项的旧值
    new_value: Bytes, //本更新项的新值
}

// SMT的MerkleProof
vector SmtProof <byte>;

// 一系列更新项
vector SmtUpdateItemVec <SmtUpdateItem>;

// 一次更新需要的所有信息
table SmtUpdateAction {
    updates:   SmtUpdateItemVec,     //本次打包涉及的状态更新
    proof:     SmtProof,             //本次打包状态转换的证明
}


// 在Witness的input_type内放置SmtUpdateAction
// 在Witness的lock_type内放置TransactionVec